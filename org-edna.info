This is org-edna.info, produced by makeinfo version 6.5 from
org-edna.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Org Edna: (org-edna). Extensible Dependencies ’N’ Actions for Org Mode tasks.
END-INFO-DIR-ENTRY


File: org-edna.info,  Node: Top,  Next: Copying,  Up: (dir)

Org Edna
********

* Menu:

* Copying::
* Introduction::                 A Brief Introduction to Edna
* Basic Features::               Finders and Actions
* Advanced Features::
* Extending Edna::               What else can it do?
* Contributing::                 I wanna help!

— The Detailed Node Listing —

Introduction

* Installation and Setup::       How to install Edna
* Basic Operation::              How to use Edna
* Blockers::                     Blocking a TODO Item
* Triggers::                     Triggering actions after completing a task
* Syntax::                       Basic explanation of Edna’s syntax

Basic Features

* Finders::                      How to find targets
* Actions::                      Next steps

Finders

* ancestors::                    Find a list of ancestors
* chain-find::                   Find a target as org-depend does
* children::                     Find all immediate children
* descendants::                  Find all descendants
* file::                         Find a file by name
* first-child::                  Find the first child of a heading
* ids::                          Find a list of headings with given IDs
* match::                        Good old tag matching
* next-sibling::                 Find the next sibling
* next-sibling-wrap::            Find the next sibling, wrapping around
* olp::                          Find a heading by its outline path
* org-file::                     Find a file in org-directory
* parent::                       Find a parent
* previous-sibling::             Find the previous sibling
* rest-of-siblings::             Find the remaining siblings
* self::
* siblings::                     Find all the siblings
* siblings-wrap::                Find the siblings, but wrap around


Actions

* Scheduled/Deadline::           Operate on planning information
* TODO State::                   Set todo state
* Archive::                      Archive targets
* Chain Property::               Copy properties from source to targets
* Clocking::                     Clock in or out of a target
* Property::                     Set properties of targets
* Priority::                     Set priorities of targets
* Tag::                          Tags of a target
* Effort::                       So much effort!


Advanced Features

* Conditions::
* Consideration::
* Setting the properties::

Conditions

* done::
* headings::
* todo-state::
* variable-set::
* has-property::
* re-search::                    Search for a regular expression
* Negating Conditions::


Extending Edna

* Naming Conventions::           How to name new functions
* Finders: Finders (1).          Making a new finder
* Actions: Actions (1).          Making a new action
* Conditions: Conditions (1).    Making a new condition

Contributing

* Bugs::
* Development::



File: org-edna.info,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

Copying
*******

Copyright (C) 2017 Free Software Foundation, Inc.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License as
     published by the Free Software Foundation, either version 3 of the
     License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.


File: org-edna.info,  Node: Introduction,  Next: Basic Features,  Prev: Copying,  Up: Top

Introduction
************

Extensible Dependencies ’N’ Actions (EDNA) for Org Mode tasks

   Edna provides an extensible means of specifying conditions which must
be fulfilled before a task can be completed and actions to take once it
is.

   Org Edna runs when either the BLOCKER or TRIGGER properties are set
on a heading, and when it is changing from a TODO state to a DONE state.

   For brevity, we use TODO state to indicate any state in
‘org-not-done-keywords’, and DONE state to indicate any state in
‘org-done-keywords’.

* Menu:

* Installation and Setup::       How to install Edna
* Basic Operation::              How to use Edna
* Blockers::                     Blocking a TODO Item
* Triggers::                     Triggering actions after completing a task
* Syntax::                       Basic explanation of Edna’s syntax


File: org-edna.info,  Node: Installation and Setup,  Next: Basic Operation,  Up: Introduction

Installation and Setup
======================

*Requirements*

Emacs   25.1
seq     2.19
org     9.0.5

   There are two ways to install Edna: From GNU ELPA, or from source.

   From ELPA:

     M-x package-install org-edna

   From Source:

     bzr branch https://bzr.savannah.gnu.org/r/org-edna-el/ org-edna
     make -C org-edna compile autoloads

   After that, add the following to your init file (typically .emacs):

     ;; Only necessary if installing from source
     (add-to-list 'load-path "/full/path/to/org-edna/")
     (load "/path/to/org-edna/org-edna-autoloads.el")

     ;; Always necessary
     (org-edna-load)

   If you ever want to disable Edna, run ‘org-edna-unload’.


File: org-edna.info,  Node: Basic Operation,  Next: Blockers,  Prev: Installation and Setup,  Up: Introduction

Basic Operation
===============

Let’s start with an example: Say you want to do laundry, but once you’ve
put your clothes in the washer, you forget about it.  Even with a tool
like org-notify or appt, Org won’t know when to remind you.  If you’ve
got them scheduled for an hour after the other, maybe you forgot one
time, or ran a little late.  Now Org will remind you too early.

   Edna can handle this for you like so:

     * TODO Put clothes in washer
       SCHEDULED: <2017-04-08 Sat 09:00>
       :PROPERTIES:
       :TRIGGER: next-sibling scheduled!("++1h")
       :END:
     * TODO Put clothes in dryer
       :PROPERTIES:
       :TRIGGER: next-sibling scheduled!("++1h")
       :BLOCKER:  previous-sibling
       :END:
     * TODO Fold laundry
       :PROPERTIES:
       :TRIGGER: next-sibling scheduled!("++1h")
       :BLOCKER:  previous-sibling
       :END:
     * TODO Put clothes away
       :PROPERTIES:
       :TRIGGER: next-sibling scheduled!("++1h")
       :BLOCKER:  previous-sibling
       :END:

   After you’ve put your clothes in the washer and mark the task DONE,
Edna will schedule the following task for one hour after you set the
first heading as done.

   Another example might be a checklist that you’ve done so many times
that you do part of it on autopilot:

     * TODO Address all TODOs in code
     * TODO Commit Code to Repository

   The last thing anyone wants is to find out that some part of the code
on which they’ve been working for days has a surprise waiting for them.
Once again, Edna can help:

     * TODO Address all TODOs in code
       :PROPERTIES:
       :BLOCKER: file("main.cpp") file("code.cpp") re-search?("TODO")
       :END:
     * TODO Commit Code to Repository


File: org-edna.info,  Node: Blockers,  Next: Triggers,  Prev: Basic Operation,  Up: Introduction

Blockers
========

A blocker indicates conditions which must be met in order for a heading
to be marked as DONE. Typically, this will be a list of headings that
must be marked as DONE.


File: org-edna.info,  Node: Triggers,  Next: Syntax,  Prev: Blockers,  Up: Introduction

Triggers
========

A trigger is an action to take when a heading is set to done.  For
example, scheduling another task, marking another task as TODO, or
renaming a file.


File: org-edna.info,  Node: Syntax,  Prev: Triggers,  Up: Introduction

Syntax
======

Edna has its own language for commands, the basic form of which is
KEYWORD(ARG1 ARG2 ...)

   KEYWORD can be any valid lisp symbol, such as key-word, KEY_WORD!, or
keyword?.

   Each argument can be one of the following:

   • A symbol, such as arg or org-mode
   • A quoted string, such as “hello” or “My name is Edna”
   • A number, such as 0.5, +1e3, or -5
   • A UUID, such as c5e30c76-879a-494d-9281-3a4b559c1a3c

   Each argument takes specific datatypes as input, so be sure to read
the entry before using it.

   The parentheses can be omitted for commands with no arguments.


File: org-edna.info,  Node: Basic Features,  Next: Advanced Features,  Prev: Introduction,  Up: Top

Basic Features
**************

The most basic features of Edna are *finders* and *actions*.

* Menu:

* Finders::                      How to find targets
* Actions::                      Next steps


File: org-edna.info,  Node: Finders,  Next: Actions,  Up: Basic Features

Finders
=======

A finder specifies locations from which to test conditions or perform
actions.  These locations are referred to as “targets”.  The current
heading, i.e.  the one that is being blocked or triggered, is referred
to as the “source” heading.

   More than one finder may be used.  In this case, the targets are
merged together, removing any duplicates.

* Menu:

* ancestors::                    Find a list of ancestors
* chain-find::                   Find a target as org-depend does
* children::                     Find all immediate children
* descendants::                  Find all descendants
* file::                         Find a file by name
* first-child::                  Find the first child of a heading
* ids::                          Find a list of headings with given IDs
* match::                        Good old tag matching
* next-sibling::                 Find the next sibling
* next-sibling-wrap::            Find the next sibling, wrapping around
* olp::                          Find a heading by its outline path
* org-file::                     Find a file in org-directory
* parent::                       Find a parent
* previous-sibling::             Find the previous sibling
* rest-of-siblings::             Find the remaining siblings
* self::
* siblings::                     Find all the siblings
* siblings-wrap::                Find the siblings, but wrap around


File: org-edna.info,  Node: ancestors,  Next: chain-find,  Up: Finders

ancestors
---------

   • Syntax: ancestors

   The ‘ancestors’ finder returns a list of the source heading’s
ancestors.

   For example:

     * TODO Heading 1
     ** TODO Heading 2
     ** TODO Heading 3
     *** TODO Heading 4
     **** TODO Heading 5
          :PROPERTIES:
          :BLOCKER:  ancestors
          :END:

   In the above example, “Heading 5” will be blocked until “Heading 1”,
“Heading 3”, and “Heading 4” are marked “DONE”, while “Heading 2” is
ignored.


File: org-edna.info,  Node: chain-find,  Next: children,  Prev: ancestors,  Up: Finders

chain-find
----------

   • Syntax: chain-find(OPTION OPTION...)

   Identical to the chain argument in org-depend, chain-find selects its
single target using the following method:

  1. Creates a list of possible targets
  2. Filters the targets from Step 1
  3. Sorts the targets from Step 2

   After this is finished, chain-find selects the first target in the
list and returns it.

   One option from each of the following three categories may be used;
if more than one is specified, the last will be used.  Apart from that,
argument order is irrelevant.

   All arguments are symbols.

   *Selection*

   • from-top: Select siblings of the source heading, starting at the
     top
   • from-bottom: As above, but from the bottom
   • from-current: Selects siblings, starting from the heading (wraps)
   • no-wrap: As above, but without wrapping

   *Filtering*

   • todo-only: Select only targets with TODO state set that isn’t a
     DONE keyword
   • todo-and-done-only: Select all targets with a TODO state set

   *Sorting*

   • priority-up: Sort by priority, highest first
   • priority-down: Same, but lowest first
   • effort-up: Sort by effort, highest first
   • effort-down: Sort by effort, lowest first


File: org-edna.info,  Node: children,  Next: descendants,  Prev: chain-find,  Up: Finders

children
--------

   • Syntax: children

   The ‘children’ finder returns a list of the *immediate* children of
the source heading.  If the source has no children, no target is
returned.

   In order to get all levels of children of the source heading, use the
*note descendants:: keyword instead.


File: org-edna.info,  Node: descendants,  Next: file,  Prev: children,  Up: Finders

descendants
-----------

   • Syntax: descendants

   The ‘descendants’ finder returns a list of all descendants of the
source heading.

     * TODO Heading 1
        :PROPERTIES:
        :BLOCKER:  descendants
        :END:
     ** TODO Heading 2
     *** TODO Heading 3
     **** TODO Heading 4
     ***** TODO Heading 5

   In the above example, “Heading 1” will block until Headings 2, 3, 4,
and 5 are DONE.


File: org-edna.info,  Node: file,  Next: first-child,  Prev: descendants,  Up: Finders

file
----

   • Syntax: file(“FILE”)

   The ‘file’ finder finds a single file, specified as a string.  The
returned target will be the minimum point in the file.

   Note that this does not give a valid heading, so any conditions or
actions that require will throw an error.  Consult the documentation for
individual actions or conditions to determine which ones will and won’t
work.

   See *note conditions: Conditions. for how to set a different
condition.  For example:

     * TODO Test
       :PROPERTIES:
       :BLOCKER:  file("~/myfile.org") headings?
       :END:

   Here, “Test” will block until myfile.org is clear of headings.


File: org-edna.info,  Node: first-child,  Next: ids,  Prev: file,  Up: Finders

first-child
-----------

   • Syntax: first-child

   Return the first child of the source heading.  If the source heading
has no children, no target is returned.


File: org-edna.info,  Node: ids,  Next: match,  Prev: first-child,  Up: Finders

ids
---

   • Syntax: id(ID1 ID2 ...)

   The ‘ids’ finder will search for headings with given IDs, using
‘org-id’.  Any number of UUIDs may be specified.  For example:

     * TODO Test
       :PROPERTIES:
       :BLOCKER:  ids(62209a9a-c63b-45ef-b8a8-12e47a9ceed9 6dbd7921-a25c-4e20-b035-365677e00f30)
       :END:

   Here, “Test” will block until the heading with ID
62209a9a-c63b-45ef-b8a8-12e47a9ceed9 and the heading with ID
6dbd7921-a25c-4e20-b035-365677e00f30 are set to “DONE”.

   Note that UUIDs need not be quoted; Edna will handle that for you.


File: org-edna.info,  Node: match,  Next: next-sibling,  Prev: ids,  Up: Finders

match
-----

   • Syntax: match(“MATCH-STRING” SCOPE SKIP)

   The ‘match’ keyword will take any arguments that ‘org-map-entries’
usually takes.  In fact, the arguments to ‘match’ are passed straight
into ‘org-map-entries’.

     * TODO Test
       :PROPERTIES:
       :BLOCKER:  match("test&mine" agenda)
       :END:

   “Test” will block until all entries tagged “test” and “mine” in the
agenda files are marked DONE.

   See the documentation for ‘org-map-entries’ for a full explanation of
the first argument.


File: org-edna.info,  Node: next-sibling,  Next: next-sibling-wrap,  Prev: match,  Up: Finders

next-sibling
------------

   • Syntax: next-sibling

   The ‘next-sibling’ keyword returns the next sibling of the source
heading, if any.


File: org-edna.info,  Node: next-sibling-wrap,  Next: olp,  Prev: next-sibling,  Up: Finders

next-sibling-wrap
-----------------

   • Syntax: next-sibling-wrap

   Find the next sibling of the source heading, if any.  If there isn’t,
wrap back around to the first heading in the same subtree.


File: org-edna.info,  Node: olp,  Next: org-file,  Prev: next-sibling-wrap,  Up: Finders

olp
---

   • Syntax: olp(“FILE” “OLP”)

   Finds the heading given by OLP in FILE. Both arguments are strings.

     * TODO Test
       :PROPERTIES:
       :BLOCKER:  olp("test.org" "path/to/heading")
       :END:

   “Test” will block if the heading “path/to/heading” in “test.org” is
not DONE.


File: org-edna.info,  Node: org-file,  Next: parent,  Prev: olp,  Up: Finders

org-file
--------

   • Syntax: org-file(“FILE”)

   A special form of ‘file’, ‘org-file’ will find FILE in
‘org-directory’.

   FILE is the relative path of a file in ‘org-directory’.  Nested files
are allowed, such as “my-directory/my-file.org”.  The returned target is
the minimum point of FILE.

     * TODO Test
       :PROPERTIES:
       :BLOCKER:  org-file("test.org")
       :END:

   Note that the file still requires an extension; the “org” here just
means to look in ‘org-directory’, not necessarily an Org mode file.


File: org-edna.info,  Node: parent,  Next: previous-sibling,  Prev: org-file,  Up: Finders

parent
------

   • Syntax: parent

   Returns the parent of the source heading, if any.


File: org-edna.info,  Node: previous-sibling,  Next: rest-of-siblings,  Prev: parent,  Up: Finders

previous-sibling
----------------

   • Syntax: previous-sibling

   Returns the previous sibling of the source heading on the same level.


File: org-edna.info,  Node: rest-of-siblings,  Next: self,  Prev: previous-sibling,  Up: Finders

rest-of-siblings
----------------

   • Syntax: rest-of-siblings

   Starting from the heading following the current one, all same-level
siblings are returned.


File: org-edna.info,  Node: self,  Next: siblings,  Prev: rest-of-siblings,  Up: Finders

self
----

   • Syntax: self

   Returns the source heading.


File: org-edna.info,  Node: siblings,  Next: siblings-wrap,  Prev: self,  Up: Finders

siblings
--------

   • Syntax: siblings

   Returns all siblings of the source heading as targets, starting from
the first sibling, and ignoring the source heading.


File: org-edna.info,  Node: siblings-wrap,  Prev: siblings,  Up: Finders

siblings-wrap
-------------

   • Syntax: siblings-wrap

   Finds the siblings on the same level as the source heading, wrapping
when it reaches the end.


File: org-edna.info,  Node: Actions,  Prev: Finders,  Up: Basic Features

Actions
=======

Once Edna has collected its targets for a trigger, it will perform
actions on them.

   Actions must always end with ’!’.

* Menu:

* Scheduled/Deadline::           Operate on planning information
* TODO State::                   Set todo state
* Archive::                      Archive targets
* Chain Property::               Copy properties from source to targets
* Clocking::                     Clock in or out of a target
* Property::                     Set properties of targets
* Priority::                     Set priorities of targets
* Tag::                          Tags of a target
* Effort::                       So much effort!


File: org-edna.info,  Node: Scheduled/Deadline,  Next: TODO State,  Up: Actions

Scheduled/Deadline
------------------

   • Syntax: scheduled!(OPTIONS)
   • Syntax: deadline!(OPTIONS)

   Set the scheduled or deadline time of any target headings.

   There are several forms that the planning keywords can take.  In the
following, PLANNING is either scheduled or deadline.

   • PLANNING!(“DATE[ TIME]”)

     Sets PLANNING to DATE at TIME. If DATE is a weekday instead of a
     date, then set PLANNING to the following weekday.  If TIME is not
     specified, only a date will be added to the target.

     Any string recognized by ‘org-read-date’ may be used for DATE.

     TIME is a time string, such as HH:MM.

   • PLANNING!(rm|remove)

     Remove PLANNING from all targets.  The argument to this form may be
     either a string or a symbol.

   • PLANNING!(copy|cp)

     Copy PLANNING info verbatim from the source heading to all targets.
     The argument to this form may be either a string or a symbol.

   • PLANNING!(“[+|-|++|–]NTHING”)

     Increment(+) or decrement(-) target’s PLANNING by N THINGs relative
     to either itself (+/-) or the current time (++/–).

     N is an integer

     THING is one of y (years), m (months), d (days), h (hours), or M
     (minutes)

   Examples:

   scheduled!(“Mon 09:00”) -> Set SCHEDULED to the following Monday at
9:00 deadline!(“++1h”) -> Set DEADLINE to one hour from now.
deadline!(copy) deadline!(“+1h”) -> Copy the source deadline to the
target, then increment it by an hour.


File: org-edna.info,  Node: TODO State,  Next: Archive,  Prev: Scheduled/Deadline,  Up: Actions

TODO State
----------

   • Syntax: todo!(NEW-STATE)

   Sets the TODO state of the target heading to NEW-STATE.

   NEW-STATE may either be a string or a symbol denoting the new TODO
state.  It can also be the empty string, in which case the TODO state is
removed.


File: org-edna.info,  Node: Archive,  Next: Chain Property,  Prev: TODO State,  Up: Actions

Archive
-------

   • Syntax: archive!

   Archives all targets with confirmation.

   Confirmation is controlled with ‘org-edna-prompt-for-archive’.  If
this option is nil, Edna will not ask before archiving targets.


File: org-edna.info,  Node: Chain Property,  Next: Clocking,  Prev: Archive,  Up: Actions

Chain Property
--------------

   • Syntax: chain!(“PROPERTY”)

   Copies PROPERTY from the source entry to all targets.  Does nothing
if the source heading has no property PROPERTY.


File: org-edna.info,  Node: Clocking,  Next: Property,  Prev: Chain Property,  Up: Actions

Clocking
--------

   • Syntax: clock-in!
   • Syntax: clock-out!

   Clocks into or out of all targets.

   ‘clock-in!’ has no special handling of targets, so be careful when
specifying multiple targets.

   In contrast, ‘clock-out!’ ignores its targets and only clocks out of
the current clock, if any.


File: org-edna.info,  Node: Property,  Next: Priority,  Prev: Clocking,  Up: Actions

Property
--------

   • Syntax: set-property!(“PROPERTY” “VALUE”)

   Sets the property PROPERTY on all targets to VALUE.

   • Syntax: delete-property!(“PROPERTY”)

   Deletes the property PROPERTY from all targets.


File: org-edna.info,  Node: Priority,  Next: Tag,  Prev: Property,  Up: Actions

Priority
--------

Sets the priority of all targets.

   • Syntax: set-priority!(“PRIORITY”)

     Set the priority to the first character of PRIORITY.

   • Syntax: set-priority!(up)

     Cycle the target’s priority up through the list of allowed
     priorities.

   • Syntax: set-priority!(down)

     Cycle the target’s priority down through the list of allowed
     priorities.

   • Syntax: set-priority!(P)

     Set the target’s priority to the character P.


File: org-edna.info,  Node: Tag,  Next: Effort,  Prev: Priority,  Up: Actions

Tag
---

   • Syntax: tag!(“TAG-SPEC”)

   Tags all targets with TAG-SPEC, which is any valid tag specification,
e.g.  tag1:tag2


File: org-edna.info,  Node: Effort,  Prev: Tag,  Up: Actions

Effort
------

   • Syntax: set-effort!(VALUE)

   Sets the effort of all targets according to VALUE:

   • If VALUE is a string, then the effort is set to VALUE
   • If VALUE is an integer, then set the value to the VALUE’th allowed
     effort property
   • If VALUE is the symbol ’increment, increment effort


File: org-edna.info,  Node: Advanced Features,  Next: Extending Edna,  Prev: Basic Features,  Up: Top

Advanced Features
*****************

* Menu:

* Conditions::
* Consideration::
* Setting the properties::


File: org-edna.info,  Node: Conditions,  Next: Consideration,  Up: Advanced Features

Conditions
==========

Edna gives you he option to specify *blocking conditions*.  Each
condition is checked for each of the specified targets; if one of the
conditions returns true for that target, then the source heading is
blocked.

   If no condition is specified, ‘!done?’ is used by default, which
means block if any target heading isn’t done.

* Menu:

* done::
* headings::
* todo-state::
* variable-set::
* has-property::
* re-search::                    Search for a regular expression
* Negating Conditions::


File: org-edna.info,  Node: done,  Next: headings,  Up: Conditions

done
----

   • Syntax: done?

   Blocks the source heading if any target heading is DONE.


File: org-edna.info,  Node: headings,  Next: todo-state,  Prev: done,  Up: Conditions

headings
--------

   • Syntax: headings?

   Blocks the source heading if any target belongs to a file that has an
Org heading.  This means that target does not have to be a heading.

     org-file("refile.org") headings?

   The above example blocks if refile.org has any headings.


File: org-edna.info,  Node: todo-state,  Next: variable-set,  Prev: headings,  Up: Conditions

todo-state
----------

   • Syntax: todo-state?(STATE)

   Blocks if any target heading has TODO state set to STATE.

   STATE may be a string or a symbol.


File: org-edna.info,  Node: variable-set,  Next: has-property,  Prev: todo-state,  Up: Conditions

variable-set
------------

   • Syntax: variable-set?(VARIABLE VALUE)

   Evaluate VARIABLE when visiting a target, and compare it with ‘equal’
against VALUE. Block the source heading if VARIABLE = VALUE.

   VARIABLE should be a symbol, and VALUE is any valid lisp expression.

     self variable-set?(test-variable 12)


File: org-edna.info,  Node: has-property,  Next: re-search,  Prev: variable-set,  Up: Conditions

has-property
------------

   • Syntax: has-property?(“PROPERTY” “VALUE”)

   Tests each target for the property PROPERTY, and blocks if it’s set
to VALUE.


File: org-edna.info,  Node: re-search,  Next: Negating Conditions,  Prev: has-property,  Up: Conditions

re-search
---------

   • Syntax: re-search?(“REGEXP”)

   Blocks the source heading if the regular expression REGEXP is present
in any of the targets.

   The targets are expected to be files, although this will work with
other targets as well.


File: org-edna.info,  Node: Negating Conditions,  Prev: re-search,  Up: Conditions

Negating Conditions
-------------------

Any condition can be negated by using ’!’ before the condition.

     match("test") !has-property?("PROP" "1")

   The above example will cause the source heading to block if any
heading tagged “test” does *not* have the property PROP set to “1”.


File: org-edna.info,  Node: Consideration,  Next: Setting the properties,  Prev: Conditions,  Up: Advanced Features

Consideration
=============

Special keyword that’s only valid for blockers.

   This keyword can allow specifying only a portion of tasks to
consider:

  1. consider(PERCENT)
  2. consider(NUMBER)
  3. consider(all) (Default)

   (1) tells the blocker to only consider some portion of the targets.
If at least PERCENT of them are in a DONE state, allow the task to be
set to DONE. PERCENT must be a decimal.

   (2) tells the blocker to only consider NUMBER of the targets.

   (3) tells the blocker to consider all following targets.

   A consideration must be specified before the targets to which it
applies:

     consider(0.5) siblings consider(all) match("find_me")

   The above code will allow task completion if at least half the
siblings are complete, and all tasks tagged “find_me” are complete.

     consider(1) ids(ID1 ID2 ID3) consider(2) ids(ID3 ID4 ID5 ID6)

   The above code will allow task completion if at least one of ID1,
ID2, and ID3 are complete, and at least two of ID3, ID4, ID5, and ID6
are complete.

   If no consideration is given, ALL is assumed.


File: org-edna.info,  Node: Setting the properties,  Prev: Consideration,  Up: Advanced Features

Setting the properties
======================

There are two ways to set the BLOCKER and TRIGGER properties: by hand,
or the easy way.  You can probably guess which way we prefer.

   With point within the heading you want to edit, type ‘M-x
org-edna-edit’.  You end up in a buffer that looks like this:

     Edit blockers and triggers in this buffer under their respective sections below.
     All lines under a given section will be merged into one when saving back to
     the source buffer.  Finish with `C-c C-c' or abort with `C-c C-k'.

     BLOCKER
     BLOCKER STUFF HERE

     TRIGGER
     TIRGGER STUFF HERE

   In here, you can edit the blocker and trigger properties for the
original heading in a cleaner environment.  More importantly, you can
complete the names of any valid keyword within the BLOCKER or TRIGGER
sections using ‘completion-at-point’.

   When finished, type ‘C-c C-c’ to apply the changes, or ‘C-c C-k’ to
throw out your changes.


File: org-edna.info,  Node: Extending Edna,  Next: Contributing,  Prev: Advanced Features,  Up: Top

Extending Edna
**************

Extending Edna is (relatively) simple.

   During operation, Edna searches for functions of the form
org-edna-TYPE/KEYWORD.

* Menu:

* Naming Conventions::           How to name new functions
* Finders: Finders (1).          Making a new finder
* Actions: Actions (1).          Making a new action
* Conditions: Conditions (1).    Making a new condition


File: org-edna.info,  Node: Naming Conventions,  Next: Finders (1),  Up: Extending Edna

Naming Conventions
==================

In order to distinguish between actions, finders, and conditions, we add
’?’ to conditions and ’!’ to actions.  This is taken from the practice
in Guile and Scheme to suffix destructive functions with ’!’ and
predicates with ’?’.

   Thus, one can have an action that files a target, and a finder that
finds a file.


File: org-edna.info,  Node: Finders (1),  Next: Actions (1),  Prev: Naming Conventions,  Up: Extending Edna

Finders
=======

Finders have the form org-edna-finder/KEYWORD, like so:

     (defun org-edna-finder/test-finder ()
       (list (point-marker)))

   All finders must return a list of markers, one for each target found,
or nil if no targets were found.


File: org-edna.info,  Node: Actions (1),  Next: Conditions (1),  Prev: Finders (1),  Up: Extending Edna

Actions
=======

Actions have the form org-edna-action/KEYWORD!:

     (defun org-edna-action/test-action! (last-entry arg1 arg2)
       )

   Each action has at least one argument: ‘last-entry’.  This is a
marker for the current entry (not to be confused with the current
target).

   The rest of the arguments are the arguments specified in the form.


File: org-edna.info,  Node: Conditions (1),  Prev: Actions (1),  Up: Extending Edna

Conditions
==========

     (defun org-edna-condition/test-cond? (neg))

   All conditions have at least one argument, “NEG”.  If NEG is non-nil,
the condition should be negated.

   Most conditions have the following form:

     (defun org-edna-condition/test-condition? (neg)
       (let ((condition (my-test-for-condition)))
         (when (org-xor condition neg)
           (string-for-blocking-entry-here))))

   For conditions, we return true if condition is true and neg is false,
or if condition is false and neg is true:

cond   neg   res
-------------------
t      t     f
t      f     t
f      t     t
f      f     f

   This is an XOR table, so we pass CONDITION and NEG into ‘org-xor’ to
get our result.

   A condition must return a string if the current entry should be
blocked.


File: org-edna.info,  Node: Contributing,  Prev: Extending Edna,  Up: Top

Contributing
************

We are all happy for any help you may provide.

   First, check out the source code on Savannah:
<https://savannah.nongnu.org/projects/org-edna-el/>

     bzr branch https://bzr.savannah.gnu.org/r/org-edna-el/ org-edna

   You’ll also want a copy of the most recent Org Mode source:

     git clone git://orgmode.org/org-mode.git

* Menu:

* Bugs::
* Development::


File: org-edna.info,  Node: Bugs,  Next: Development,  Up: Contributing

Bugs
====

There are two ways to submit bug reports:

  1. Using the bug tracker at Savannah
  2. Sending an email using ‘org-edna-submit-bug-report’

   When submitting a bug report, be sure to include the Edna form that
caused the bug, with as much context as possible.


File: org-edna.info,  Node: Development,  Prev: Bugs,  Up: Contributing

Development
===========

If you’re new to bazaar, we recommend using Emacs’s built-in VC package.
It eases the overhead of dealing with a brand new VCS with a few
standard commands.  For more information, see the info page on it (In
Emacs, this is C-h r m Introduction to VC RET).

   To contribute with bazaar, you can do the following:

     # Hack away and make your changes
     $ bzr commit -m "Changes I've made"
     $ bzr send -o file-name.txt

   Then, use ‘org-edna-submit-bug-report’ and attach “file-name.txt”.
We can then merge that into the main development branch.

   There are a few rules to follow:

   • Verify that any new Edna keywords follow the appropriate naming
     conventions
   • Any new keywords should be documented
   • We operate on headings, not headlines
        • Use one word to avoid confusion
   • Run ’make check’ to verify that your mods don’t break anything
   • Avoid additional or altered dependencies if at all possible
        • Exception: New versions of Org mode are allowed



Tag Table:
Node: Top225
Node: Copying3142
Node: Introduction3959
Node: Installation and Setup4907
Node: Basic Operation5700
Node: Blockers7551
Node: Triggers7837
Node: Syntax8099
Node: Basic Features8789
Node: Finders9092
Node: ancestors10595
Node: chain-find11179
Node: children12517
Node: descendants12916
Node: file13426
Node: first-child14175
Node: ids14423
Node: match15084
Node: next-sibling15722
Node: next-sibling-wrap15967
Node: olp16269
Node: org-file16681
Node: parent17326
Node: previous-sibling17512
Node: rest-of-siblings17756
Node: self18019
Node: siblings18175
Node: siblings-wrap18433
Node: Actions18666
Node: Scheduled/Deadline19408
Node: TODO State20998
Node: Archive21366
Node: Chain Property21686
Node: Clocking21969
Node: Property22381
Node: Priority22703
Node: Tag23272
Node: Effort23489
Node: Advanced Features23878
Node: Conditions24090
Node: done24705
Node: headings24869
Node: todo-state25245
Node: variable-set25501
Node: has-property25930
Node: re-search26199
Node: Negating Conditions26559
Node: Consideration26946
Node: Setting the properties28153
Node: Extending Edna29233
Node: Naming Conventions29723
Node: Finders (1)30186
Node: Actions (1)30552
Node: Conditions (1)31017
Node: Contributing31907
Node: Bugs32379
Node: Development32731

End Tag Table


Local Variables:
coding: utf-8
End:
