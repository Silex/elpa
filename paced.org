#+TITLE: Paced
#+AUTHOR: Ian Dunn
#+EMAIL: dunni@gnu.org
#+DATE: {{{modification-time}}}

#+STARTUP: overview
#+STARTUP: indent
#+TODO: FIXME | FIXED
#+OPTIONS: toc:2 num:nil timestamp:nil \n:nil |:t ':t email:t
#+OPTIONS: *:t <:t d:nil todo:nil pri:nil tags:not-in-toc

#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: paced
#+TEXINFO_DIR_DESC: Predictive Abbreviation Completion and Expansion using Dictionaries


* Copying
Copyright (C) 2017 Ian Dunn

#+BEGIN_QUOTE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+END_QUOTE
* Introduction
Paced (Predictive Abbreviation Completion and Expansion using Dictionaries)
provides a completion backend based on what a user has already written.

Paced scans one or more files or buffers and constructs a table of words,
weighted by how often they're used.

Once it's constructed this table, it can present them to the user for
completion, sorted by their weights.

Creating a new dictionary is easy; just use ~paced-create-new-dictionary~ to
create a new dictionary, then set the population commands and sort method.

Dictionaries are persistent; they're saved with ~paced-save-named-dictionary~ or
~paced-save-all-dictionaries~.

Population commands tell a dictionary how it should refresh its usage table.
The different types of populators are documented in ~paced--populator-alist~.

No completion frontend is provided, but a function for
~completion-at-point-functions~ is given.

** Terminology

- Dictionary :: A collection of words and their usage counts.

- Populator :: A method of loading a file into a dictionary.

** Similar Packages
There are a few Emacs packages that have similar goals to paced, and provided
some of the inspiration and motivation behind it.
*** pabbrev
The [[http://github.com/phillord/pabbrev][pabbrev]] package by Phillip Lord scans text of the current buffer while Emacs
is idle and presents the user with the most common completions.

One of the major downsides to pabbrev is that the data it collects doesn't
persist between Emacs sessions.  For a few files that are always open, such as
org agenda files, pabbrev works great.  For files that aren't always open, like
prose or source files, you've got to retrain pabbrev every time you restart
Emacs.

The benefit of pabbrev dies down if the suggested word isn't the one you need.
Then you've still got to search through a list of suggestions, which takes away
from typing.

That's not to say that pabbrev is all bad.  It keeps up-to-date usage and prefix
hashes of all buffers of the same mode, and scanning, or "scavenging", blends
seamlessly into the background.  Completion is just a hash table lookup, so it
can handle completion in microseconds.
*** predictive
The [[http://www.dr-qubit.org/git/predictive.git][predictive]] package by Toby Cubitt scans text of the current buffer on user
command.  The usage data is stored in a dictionary, which can then be saved to a
disk.  Extensions are provided to ~completion-at-point~, or predictive's built-in
frontend can be used.  It has a safety precaution where it only adds existing
words to a dictionary, unless the user allows this.  This is to avoid adding
typos to a dictionary.

Completion was also done intelligently, grouping commonly used words together
and optionally suggesting shorter words before longer words.

While the frontend and backend are separate, the frontend is required to
populate a dictionary.  There is no way to exclude part of the buffer's text
from dictionary population.  The safety precaution predictive has where it only
adds a word to a dictionary if it already exists was tedious, since I didn't
need it to do that.
** Installation

*Requirements*

| Emacs |  26.1 |
| async | 1.9.2 |

There are two ways to install paced; From GNU ELPA, or from source.

From ELPA:

#+begin_example
M-x package-install paced
#+end_example

From Source:

#+begin_src shell
bzr branch https://bzr.savannah.gnu.org/r/paced-el paced
cd paced
./bootstrap.sh
make all
#+end_src

After that, add the following to your init file (typically .emacs):

#+BEGIN_SRC emacs-lisp
;; Only necessary if installing from source
(add-to-list 'load-path "/full/path/to/paced/")
(load "paced-autoloads.el")
#+END_SRC
** Creating a Dictionary

Now that you've got paced installed, it's time to create a new dictionary.

#+begin_example
M-x paced-create-new-dictionary RET DICTIONARY_NAME RET DICTIONARY_FILE RET
#+end_example

Let's explain those two arguments:

First, you've got DICTIONARY_NAME.  This is a key that will be used to reference
the new dictionary.  It's a symbol, so it should adhere to Emacs's symbol syntax
(no dots or quotes, etc.).  We recommend something short, like 'new-dict',
'my-dict', 'writing'.

Next is the file where the dictionary will be stored.  This is typically stored
in ~paced-dictionary-directory~, from which all dictionaries will be loaded with
~paced-load-all-dictionaries~ (more on that later).  For now, it's important to
know that ~paced-load-all-dictionaries~ is the easiest way to load dictionaries
when paced is loaded.

After you've run the above command, you will be taken to the customization
buffer.  This is where you can set population commands.
** Editing a Dictionary
In order to edit a dictionary, paced provides ~paced-edit-named-dictionary~ and
~paced-edit-current-dictionary~.

The edit buffer provides the options to change the population commands, case
sensitivity, dictionary storage name, and sort method.  Each of these is
documented in the edit buffer.

* Dictionaries
** Enable Certain Dictionaries in Certain Places

Paced provides a mechanism called the "enable list", that allows a user to
enable certain dictionaries given certain conditions.

There are two enable lists: a global and local one.

* Population Commands
